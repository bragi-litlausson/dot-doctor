#+TITLE: Dot Doctor Code
This is my first attempt of doing literate programming, don't be to harsh. ;)

This document will go over the implementation of Dot Doctor. For me info about the project check =README.org=.

* Helpers
** Environ Helper
#+begin_src python :tangle environ_helper.py
import os
from os import environ
#+end_src
*** Environmental variable exist
#+begin_src python :tangle environ_helper.py
def env_exists(name):
    return name in environ
#+end_src
*** Get environmental variable
#+begin_src python :tangle environ_helper.py
def get_env(name):
    return environ.get(name)
#+end_src
** Curses Helper
#+begin_src python :tangle curses_helper.py
import curses
#+end_src
*** Init Color Pairs
This method is used to set up additional color pairs for curses to use. By default only one color pair exists (0: white on black).
#+begin_src python :tangle curses_helper.py
def init_color_pairs():
    curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
    curses.init_pair(6, curses.COLOR_GREEN, curses.COLOR_WHITE)
    curses.init_pair(7, curses.COLOR_RED, curses.COLOR_WHITE)
#+end_src

#+RESULTS:
: None

*** Draw Error page
This is method is a quick and easy way to create error message.
#+begin_src python :tangle curses_helper.py
def draw_error_page(stdscr, header, message):
    stdscr.clear()
    stdscr.addstr(3, 3, header, curses.color_pair(2))
    stdscr.addstr(4, 3, message, curses.color_pair(3))
#+end_src
*** Draw Config row
#+begin_src python :tangle curses_helper.py
def draw_config_row(stdscr, dot_data, index, active):
    mod = 0
    if active:
        mod = 5
    if dot_data.status:
        stdscr.addstr(1+index, 2, dot_data.name, curses.color_pair(1+mod))
    else:
        stdscr.addstr(1+index, 2, dot_data.name, curses.color_pair(2+mod))
#+end_src

** DotData
To save my sanity I had to create class for storing all the relevant info about any given dot file.
#+begin_src python :tangle dotdata.py
class DotData:
    enabled = False
    def __init__(self, name, relative_path, status):
        self.name = name
        self.relative_path = relative_path
        self.status = status
    def set_status(self, status):
        self.status = status
#+end_src
* Shebang & imports
#+begin_src python :tangle dotdoctor.py
#!/usr/bin/env python3
#+end_src
** Python
#+begin_src python :tangle dotdoctor.py
import os
import sys
import shutil
from environ_helper import (env_exists, get_env)
from curses_helper import (init_color_pairs, draw_error_page, draw_config_row)
from dotdata import DotData
#+end_src
** Curses
#+begin_src python :tangle dotdoctor.py
import curses
from curses import wrapper
#+end_src

* Init
** Checking variable
To locate directory with config files *dot doctor* uses environmental variable called =dotdoctor_dir=.
I guess at some point I could change this to variable stored in config file, but for the first version it will be more than enough.
#+begin_src python :tangle dotdoctor.py
def get_dotdoctor_dir_path():
    if env_exists("dotdoctor_dir"):
        global dotdoctor_dir
        dotdoctor_dir = get_env("dotdoctor_dir")
    else:
        wrapper(draw_env_missing_error)
def draw_env_missing_error(stdscr):
    init_color_pairs()
    header = "ERROR"
    message = "Environemntal variable $dotdoctor_dir is not set."
    draw_error_page(stdscr, header, message)
    stdscr.getkey()
#+end_src
** Check the dotdoctor_dir
Call me crazy but checking if the directory exits and has at least one file inside sounds like a good idea.
#+begin_src python :tangle dotdoctor.py
def validate_dotdoctor_dir():
    if os.path.exists(dotdoctor_dir) == False:
        wrapper(draw_dir_missing_error)
    if len(os.listdir(dotdoctor_dir)) == 0:
        wrapper(draw_dir_empty_error)
def draw_dir_missing_error(stdscr):
    init_color_pairs()
    header = "ERROR"
    message = "{} does not exist.".format(dotdoctor_dir)
    draw_error_page(stdscr, header, message)
    stdscr.getkey()
def draw_dir_empty_error(stdscr):
    init_color_pairs()
    header = "ERROR"
    message = "{} is empty.".format(dotdoctor_dir)
    draw_error_page(stdscr, header, message)
    stdscr.getkey()
#+end_src
** Create list of available files and directories
After everything is ready to go, application goes into dot files directory and creates list of directories and files inside. For now it will only go inside of =.config= directory, other directories will be treated similar to files.
#+begin_src python :tangle dotdoctor.py
def create_config_list():
    global config_list
    config_list = []
    files_list = os.listdir(dotdoctor_dir)
    for file in files_list:
        if file != ".config":
            config_list.append(DotData(file, file, False))
    if '.config' in os.listdir(dotdoctor_dir):
        path = os.path.join(dotdoctor_dir, ".config")
        files_list = os.listdir(path)
        for file in files_list:
            config_list.append(DotData(file, os.path.join(".config", file), False))
    config_list.sort(key=lambda x: x.name)

#+end_src
** Update list of enabled configs
After list of files and directories is done, dot doctor goes into home directory and check what files were replaced with symbolic links. If the symbolic link is present config is marked as enabled.
#+begin_src python :tangle dotdoctor.py
def update_dot_data_status():
    home_path = get_env("HOME")
    for dot_data in config_list:
        dot_path = os.path.join(home_path, dot_data.relative_path)
        if os.path.exists(dot_path) and os.path.islink(dot_path):
            dot_data.set_status(True)
#+end_src
** Create backup directory
When activating config dot doctor will move existing files to =.backup= directory so we need to check if it exists and if it doesn't create it.
#+begin_src python :tangle dotdoctor.py
def set_up_backup_directory():
    path = os.path.dirname(sys.argv[0])
    path = os.path.join(path, ".backup")
    if os.path.exists(path) == False:
        os.mkdir(path)
        path = os.path.join(path, ".config")
        os.mkdir(path)
#+end_src

** Calling init methods
#+begin_src python :tangle dotdoctor.py
def init():
    get_dotdoctor_dir_path()
    validate_dotdoctor_dir()
    set_up_backup_directory()
    create_config_list()
    update_dot_data_status()
#+end_src

* Config GUI logic
** Draw list of available configs
#+begin_src python :tangle dotdoctor.py
current_index = 0
def config_list_loop(stdscr):
    curses.curs_set(False)
    init_color_pairs()
    global current_index
    while True:
        stdscr.clear()
        draw_list_of_configs(stdscr, current_index)
        if process_input(stdscr.getch()):
            break
def draw_list_of_configs(stdscr, current_index):
    rows, cols = stdscr.getmaxyx()
    row = 80
    for index, dot_data in enumerate(config_list):
        if len(config_list) <= rows-2:
            draw_config_row(stdscr, dot_data, index, current_index == index)
        elif current_index < 3 and index < rows-3:
            draw_config_row(stdscr, dot_data, index, current_index == index)
        elif current_index >= 3 and index > current_index -3 and index < rows -3 + current_index-2:
            draw_config_row(stdscr, dot_data, index-(current_index-2), current_index == index)
def process_input(c):
    global current_index
    if c == ord('q'):
        return True
    if c == ord('k'):
        current_index -= 1
    if c == ord('j'):
        current_index += 1
    if c == 10:
        toggle_config()
    clamp_current_index()
    return False

def toggle_config():
    global config_list, current_index
    data = config_list[current_index]
    if data.status == False:
        activate_dot_data(data)
    else:
        deactivate_dot_data(data)
def activate_dot_data(dot_data):
    global dotdoctor_dir
    dot_data.set_status(True)
    home_path = os.path.join(get_env("HOME"), dot_data.relative_path)
    backup_path = os.path.join("./.backup", dot_data.relative_path)
    backup_path = os.path.abspath(backup_path)
    config_path = os.path.join(dotdoctor_dir, dot_data.relative_path)
    config_path = os.path.abspath(config_path)
    if os.path.exists(home_path):
        shutil.move(home_path, backup_path)
    os.symlink(config_path, home_path)
def deactivate_dot_data(dot_data):
    global dotdoctor_dir
    dot_data.set_status(False)
    home_path = os.path.join(get_env("HOME"), dot_data.relative_path)
    backup_path = os.path.join("./.backup", dot_data.relative_path)
    backup_path = os.path.abspath(backup_path)
    os.unlink(home_path)
    shutil.move(backup_path, home_path)
def clamp_current_index():
    global current_index
    if current_index < 0:
        current_index = 0
    if current_index >= len(config_list):
        current_index = len(config_list)-1
#+end_src

* Main loop
#+begin_src python :tangle dotdoctor.py
if __name__ == "__main__":
    init()
    wrapper(config_list_loop)
#+end_src
* install.sh
#+begin_src shell :tangle install.sh
path=$(dirname $0)
dot_doctor="/dotdoctor.py"
ln -s $path$dot_doctor "/usr/local/bin/dotdoctor"
chmod +x "/usr/local/bin/dotdoctor"
#+end_src
